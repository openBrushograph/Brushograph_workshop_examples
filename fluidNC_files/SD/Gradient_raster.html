<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FluidNC Optimized Dip Generator</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #f4f4f9; padding: 20px; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; color: #2c3e50; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .section { background: #fafafa; padding: 15px; border-radius: 6px; border: 1px solid #eee; }
        .section h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: #2980b9; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
        input[type="number"], input[type="text"] { width: 100%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        .checkbox-group { display: flex; align-items: center; margin-bottom: 10px; }
        .checkbox-group input { width: auto; margin-right: 10px; }
        button { background: #e67e22; color: white; border: none; padding: 12px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 10px; transition: background 0.3s; }
        button:hover { background: #d35400; }
        #log { width: 100%; height: 150px; background: #222; color: #0f0; font-family: monospace; padding: 10px; border-radius: 4px; overflow-y: scroll; box-sizing: border-box; margin-top: 20px; font-size: 12px; }
        canvas { display: none; }
        .preview-area { margin-top: 20px; text-align: center; }
        .preview-area img { max-width: 100%; border: 1px solid #ddd; }
        .file-input { background: #ecf0f1; padding: 20px; text-align: center; border: 2px dashed #bdc3c7; border-radius: 6px; cursor: pointer; }
    </style>
</head>
<body>

<div class="container">
    <h1>Optimized Dip Painter</h1>
    
    <div class="file-input">
        <label for="imageInput" style="cursor: pointer;">üñºÔ∏è Click to Select Image</label>
        <input type="file" id="imageInput" accept="image/*" style="display:none">
        <div id="fileName">No file selected</div>
    </div>

    <div class="grid">
        <div class="section">
            <h3>üé® Painting Parameters</h3>
            <label>Output Width (mm)</label>
            <input type="number" id="width" value="140.0" step="0.1">
            <label>Max Depth (Z mm, negative)</label>
            <input type="number" id="maxDepth" value="-1.0" step="0.1">
            <label>**Dip Intensity Threshold (0-255)**</label>
            <input type="number" id="dipIntensityThreshold" value="150" step="1">
            <label>Feed Rate (mm/min)</label>
            <input type="number" id="feedRate" value="1500">
            <label>X Offset (mm)</label>
            <input type="number" id="xOffset" value="0.0">
            <label>Y Offset (mm)</label>
            <input type="number" id="yOffset" value="25.0">
        </div>

        <div class="section">
            <h3>üö∞ Dipping & Wiping</h3>
            <label>Dip Trigger Distance (mm)</label>
            <input type="number" id="dipThreshold" value="500.0">
            <div class="grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 0;">
                <div><label>Dip X</label><input type="number" id="dipX" value="63.0"></div>
                <div><label>Dip Y</label><input type="number" id="dipY" value="0.0"></div>
                <div><label>Dip Z</label><input type="number" id="dipZ" value="0.0"></div>
            </div>
            <label>Dip Duration (sec)</label>
            <input type="number" id="dipDuration" value="0.001" step="0.1">
            <label>Wipe Radius (mm)</label>
            <input type="number" id="wipeRadius" value="15.0">
            <div class="checkbox-group">
                <input type="checkbox" id="removeDrops" checked>
                <label for="removeDrops">Enable Wipe/Shake</label>
            </div>
        </div>

        <div class="section">
            <h3>üìê Z Heights & Backlash</h3>
            <label>Safe Z (Travel)</label>
            <input type="number" id="zSafe" value="2.0">
            <label>Safe Z (Dip Travel)</label>
            <input type="number" id="zSafeDip" value="5.0">
            <label>Wipe Height (Z)</label>
            <input type="number" id="zWipe" value="2.0">
            <label>Global Z Offset</label>
            <input type="number" id="zGlobal" value="0.0">
            <hr>
            <label>Backlash X (mm)</label>
            <input type="number" id="bx" value="0.5" step="0.01">
            <label>Backlash Y (mm)</label>
            <input type="number" id="by" value="1.6" step="0.01">
        </div>
    </div>
    
    <label>Line Spacing (mm) - Only used for sampling, not for rastering.</label>
    <input type="number" id="lineSpacing" value="0.6" step="0.1">

    <button id="generateBtn" onclick="generateGCode()">‚ú® Generate Optimized G-Code</button>
    <button id="downloadBtn" onclick="downloadGCode()" style="background: #3498db; display:none; margin-top: 10px;">üíæ Download File</button>

    <textarea id="log" readonly></textarea>
    
    <div class="preview-area">
        <canvas id="canvas"></canvas>
    </div>
</div>

<script>
// =============================================================================
// LOGIC: Backlash Compensator
// =============================================================================
class BacklashCompensator {
    constructor(bx, by) {
        this.bx = bx;
        this.by = by;
        this.threshold = 0.05;
        this.safeFeed = 200;
        
        this.currentX = 0.0;
        this.currentY = 0.0;
        this.offsetX = 0.0;
        this.offsetY = 0.0;
        this.dirX = 0; // 0=None, 1=Pos, -1=Neg
        this.dirY = 0;
    }

    processLines(lines) {
        let newGcode = [];
        
        // Regex to parse G-code
        const pX = /X([-\d\.]+)/;
        const pY = /Y([-\d\.]+)/;
        const pZ = /Z([-\d\.]+)/;
        const pF = /F([-\d\.]+)/;

        let currentFeed = 500.0;

        for (let line of lines) {
            let originalLine = line.trim();
            if (!originalLine || originalLine.startsWith(';')) {
                newGcode.push(originalLine);
                continue;
            }

            let targetX = this.currentX;
            let targetY = this.currentY;
            let targetZ = null;
            let hasMove = false;

            let mx = originalLine.match(pX);
            if (mx) { targetX = parseFloat(mx[1]); hasMove = true; }

            let my = originalLine.match(pY);
            if (my) { targetY = parseFloat(my[1]); hasMove = true; }

            let mz = originalLine.match(pZ);
            if (mz) { targetZ = parseFloat(mz[1]); }

            let mf = originalLine.match(pF);
            if (mf) { currentFeed = parseFloat(mf[1]); }

            if (!hasMove) {
                newGcode.push(originalLine);
                continue;
            }

            // --- X Axis Logic ---
            let dx = targetX - this.currentX;
            if (Math.abs(dx) > this.threshold) {
                let newDirX = dx > 0 ? 1 : -1;
                if (this.dirX !== 0 && newDirX !== this.dirX) {
                    let change = newDirX === 1 ? this.bx : -this.bx;
                    this.offsetX += change;
                    
                    let phyX = this.currentX + this.offsetX;
                    let phyY = this.currentY + this.offsetY;

                    newGcode.push(`; --- FIX X Backlash: ${change.toFixed(3)}mm ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirX = newDirX;
            }

            // --- Y Axis Logic ---
            let dy = targetY - this.currentY;
            if (Math.abs(dy) > this.threshold) {
                let newDirY = dy > 0 ? 1 : -1;
                if (this.dirY !== 0 && newDirY !== this.dirY) {
                    let change = newDirY === 1 ? this.by : -this.by;
                    this.offsetY += change;

                    let phyX = this.currentX + this.offsetX;
                    let phyY = this.currentY + this.offsetY;

                    newGcode.push(`; --- FIX Y Backlash: ${change.toFixed(3)}mm ---`);
                    newGcode.push(`G0 X${phyX.toFixed(3)} Y${phyY.toFixed(3)} F${this.safeFeed}`);
                    newGcode.push(`G0 F${parseInt(currentFeed)}`);
                }
                this.dirY = newDirY;
            }

            // --- Reconstruct Line ---
            let finalX = targetX + this.offsetX;
            let finalY = targetY + this.offsetY;

            let cmd = originalLine.toUpperCase().includes("G0") ? "G0" : "G1";
            let out = `${cmd} X${finalX.toFixed(3)} Y${finalY.toFixed(3)}`;
            
            if (targetZ !== null) out += ` Z${targetZ.toFixed(3)}`;
            if (cmd === "G1" && originalLine.toUpperCase().includes("F")) out += ` F${parseInt(currentFeed)}`;
            if (cmd === "G4") out = originalLine; // Preserve G4 lines

            newGcode.push(out);

            this.currentX = targetX;
            this.currentY = targetY;
        }

        return newGcode;
    }
}

// =============================================================================
// LOGIC: Optimized Dip Generator (Replaces RasterGenerator)
// =============================================================================
class DipGenerator {
    constructor(params) {
        this.p = params;
        this.gcode = [];
        
        // Z heights adjustment
        this.zSafe = this.p.zSafe + this.p.zGlobal;
        this.zSafeDip = this.p.zSafeDip + this.p.zGlobal;
        this.zWipeTravel = this.p.zWipe + this.p.zGlobal;
        this.dipLocation = {
            x: this.p.dipX,
            y: this.p.dipY,
            z: this.p.dipZ + this.p.zGlobal
        };

        this.trayEnterRadius = this.p.wipeRadius > 0 ? this.p.wipeRadius * 0.3 : 0;
        this.distSinceLastDip = 0.0;
        this.currentX = this.p.xOffset;
        this.currentY = this.p.yOffset;
    }

    log(msg) {
        const logEl = document.getElementById("log");
        logEl.value += msg + "\n";
        logEl.scrollTop = logEl.scrollHeight;
    }

    removeDrops(trayX, trayY, x, y) {
        let dx = x - trayX;
        let dy = y - trayY;
        let dist = Math.hypot(dx, dy);
        let baseAngle = (dist === 0) ? 0.0 : Math.atan2(dy, dx);

        // Random variation +/- 12 degrees
        let variation = (Math.random() * 24 - 12) * (Math.PI / 180);
        let angle = baseAngle + variation;

        let ux = Math.cos(angle);
        let uy = Math.sin(angle);

        let x1 = trayX + ux * this.trayEnterRadius;
        let y1 = trayY + uy * this.trayEnterRadius;
        let x2 = trayX + ux * this.p.wipeRadius;
        let y2 = trayY + uy * this.p.wipeRadius;

        this.gcode.push(`; remove_drops angle=${(angle * 180/Math.PI).toFixed(1)}`);
        this.gcode.push(`G0 X${x1.toFixed(3)} Y${y1.toFixed(3)}`);
        this.gcode.push(`G0 Z${this.zWipeTravel.toFixed(3)}`);
        this.gcode.push(`G1 F600`);
        this.gcode.push(`G1 X${x2.toFixed(3)} Y${y2.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);
    }

    performDip(targetX, targetY) {
        this.gcode.push("; --- Dip Cycle ---");
        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
        this.gcode.push(`G0 X${this.dipLocation.x.toFixed(3)} Y${this.dipLocation.y.toFixed(3)}`);
        
        // Dip
        this.gcode.push(`G1 Z${this.dipLocation.z.toFixed(3)} F800`);
        if (this.p.dipDuration > 0) {
            this.gcode.push(`G4 P${this.p.dipDuration.toFixed(1)}`);
        }

        // Lift to wipe height
        this.gcode.push(`G1 Z${this.zWipeTravel.toFixed(3)} F800`);

        let tx = (targetX === null) ? this.dipLocation.x + this.p.wipeRadius : targetX;
        let ty = (targetY === null) ? this.dipLocation.y : targetY;

        if (this.p.removeDrops && this.p.wipeRadius > 0) {
            this.removeDrops(this.dipLocation.x, this.dipLocation.y, tx, ty);
        }

        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)} F${this.p.feedRate}`);
        this.gcode.push("; --- End Dip ---");
        this.distSinceLastDip = 0.0;
    }

    process(imgData, widthPx, heightPx) {
        this.log("Starting Optimized Dip generation...");
        this.gcode = [];

        // Headers
        this.gcode.push("G90");
        this.gcode.push("G21");
        this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);
        this.gcode.push(`G0 F${this.p.feedRate}`);

        if (this.p.dipThreshold > 0) {
            this.log("Performing initial dip...");
            this.performDip(null, null);
        }
        
        this.gcode.push(`G0 X${this.p.xOffset.toFixed(3)} Y${this.p.yOffset.toFixed(3)} Z${this.zSafe.toFixed(3)}`);

        // --- 1. Identify all Dip Points ---
        let scaleFactor = this.p.width / widthPx;
        let dipPoints = [];

        // The 'lineSpacing' parameter is reused here as a sampling resolution
        const step = Math.max(1, Math.round(this.p.lineSpacing / scaleFactor)); 

        for (let y = 0; y < heightPx; y += step) {
            for (let x = 0; x < widthPx; x += step) {
                let intensity = this.getPixelIntensity(imgData, widthPx, x, y);

                // Use the user-defined threshold (0=Black, 255=White)
                if (intensity < this.p.dipIntensityThreshold) { 
                    
                    let finalX = x * scaleFactor + this.p.xOffset;
                    // Correct for inverted Y: CNC Y0 is bottom. Image Y0 is top.
                    let finalY = (heightPx - 1 - y) * scaleFactor + this.p.yOffset;
                    
                    // Calculate Z-depth based on darkness
                    let zDepth = -Math.abs(this.p.maxDepth) * (1 - (intensity / 255.0)) + this.p.zGlobal;
                    
                    dipPoints.push({ x: finalX, y: finalY, z: zDepth, visited: false });
                }
            }
        }

        this.log(`Found ${dipPoints.length} dip points with threshold ${this.p.dipIntensityThreshold}.`);

        // --- 2. Optimized Path Planning (Nearest Neighbor/Greedy) ---
        let unvisitedCount = dipPoints.length;
        let currentX = this.p.xOffset;
        let currentY = this.p.yOffset;

        while (unvisitedCount > 0) {
            let closestPoint = null;
            let minDistance = Infinity;
            let closestIndex = -1;

            // Find the nearest unvisited point
            for (let i = 0; i < dipPoints.length; i++) {
                if (!dipPoints[i].visited) {
                    let dx = dipPoints[i].x - currentX;
                    let dy = dipPoints[i].y - currentY;
                    let dist = Math.hypot(dx, dy);

                    if (dist < minDistance) {
                        minDistance = dist;
                        closestPoint = dipPoints[i];
                        closestIndex = i;
                    }
                }
            }

            if (!closestPoint) break;

            // Update distance tracking for dip cycles
            this.distSinceLastDip += minDistance;

            // --- 3. Generate G-Code for the movement and plunge ---
            
            // Travel to target at safe Z (G0)
            this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
            this.gcode.push(`G0 X${closestPoint.x.toFixed(3)} Y${closestPoint.y.toFixed(3)}`);
            
            // Dip Check (before plunging)
            if (this.p.dipThreshold > 0 && this.distSinceLastDip >= this.p.dipThreshold) {
                this.performDip(closestPoint.x, closestPoint.y);
                // After dipping, move back to target X/Y, which is needed after a wipe/shake
                this.gcode.push(`G0 X${closestPoint.x.toFixed(3)} Y${closestPoint.y.toFixed(3)}`);
            }

            // Plunge to painting depth (G1)
            this.gcode.push(`G1 Z${closestPoint.z.toFixed(3)} F${this.p.feedRate}`);
            
            // Lift back to safe Z (G0)
            this.gcode.push(`G0 Z${this.zSafe.toFixed(3)}`);

            // Update state
            dipPoints[closestIndex].visited = true;
            unvisitedCount--;
            currentX = closestPoint.x;
            currentY = closestPoint.y;
        }

        // Footer
        this.gcode.push(`G0 Z${this.zSafeDip.toFixed(3)}`);
        this.gcode.push(`G0 X${this.p.xOffset.toFixed(3)} Y${this.p.yOffset.toFixed(3)}`);
        this.gcode.push("M2");

        this.log("Optimized Dip generation complete.");
        
        // BACKLASH PROCESSING
        if (this.p.bx > 0 || this.p.by > 0) {
            this.log(`Applying Backlash (X:${this.p.bx}, Y:${this.p.by})...`);
            const bl = new BacklashCompensator(this.p.bx, this.p.by);
            this.gcode = bl.processLines(this.gcode);
        }

        this.log("Finished.");
        return this.gcode.join("\n");
    }

    getPixelIntensity(imgData, width, x, y) {
        // imgData is RGBA. Index = (y * width + x) * 4
        let idx = (y * width + x) * 4;
        let r = imgData[idx];
        let g = imgData[idx + 1];
        let b = imgData[idx + 2];
        return (r + g + b) / 3.0; // Average R, G, B for grayscale intensity
    }
}

// =============================================================================
// UI HANDLERS (Same as original, but using new class name)
// =============================================================================
let finalGCodeText = "";

document.getElementById('imageInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if(file){
        document.getElementById('fileName').textContent = file.name;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.getElementById('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
            }
            img.src = evt.target.result;
        }
        reader.readAsDataURL(file);
    }
});

function generateGCode() {
    const canvas = document.getElementById('canvas');
    if (canvas.width === 0) {
        alert("Please load an image first.");
        return;
    }

    const ctx = canvas.getContext('2d');
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    // Gather Parameters
    const params = {
        width: parseFloat(document.getElementById('width').value),
        maxDepth: parseFloat(document.getElementById('maxDepth').value),
        dipIntensityThreshold: parseFloat(document.getElementById('dipIntensityThreshold').value), // New parameter
        lineSpacing: parseFloat(document.getElementById('lineSpacing').value), // Used as sampling resolution
        feedRate: parseFloat(document.getElementById('feedRate').value),
        xOffset: parseFloat(document.getElementById('xOffset').value),
        yOffset: parseFloat(document.getElementById('yOffset').value),
        dipThreshold: parseFloat(document.getElementById('dipThreshold').value),
        dipX: parseFloat(document.getElementById('dipX').value),
        dipY: parseFloat(document.getElementById('dipY').value),
        dipZ: parseFloat(document.getElementById('dipZ').value),
        dipDuration: parseFloat(document.getElementById('dipDuration').value),
        wipeRadius: parseFloat(document.getElementById('wipeRadius').value),
        removeDrops: document.getElementById('removeDrops').checked,
        zSafe: parseFloat(document.getElementById('zSafe').value),
        zSafeDip: parseFloat(document.getElementById('zSafeDip').value),
        zWipe: parseFloat(document.getElementById('zWipe').value),
        zGlobal: parseFloat(document.getElementById('zGlobal').value),
        bx: parseFloat(document.getElementById('bx').value),
        by: parseFloat(document.getElementById('by').value)
    };

    document.getElementById('log').value = "";
    const generator = new DipGenerator(params); // Using the new class name
    
    // Use setTimeout to allow UI to update before processing hangs the main thread
    setTimeout(() => {
        finalGCodeText = generator.process(imgData, canvas.width, canvas.height);
        document.getElementById('downloadBtn').style.display = 'block';
    }, 100);
}

function downloadGCode() {
    const blob = new Blob([finalGCodeText], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "optimized_dip_paint.gcode";
    a.click();
    window.URL.revokeObjectURL(url);
}
</script>

</body>
</html>